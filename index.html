<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
	<script src="jquery-3.3.1.min.js"></script>
	
    <title>Bomberman</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

</head>
<body style="background-color: black;">

    <canvas id="cvs" width="680" height="520"></canvas>

    <script>

        var c = document.getElementById('cvs');
        var ctx = c.getContext('2d');
        var timer = new Timer();
        timer.interval = 5;
        timer.isLoop = true;
        var blockSize = 40;
        var playerSize = 20;
        var droppedBombs = [];
        var explosionTime = 2000;
        var initialHealth = 3;
        var initialBombRange = 2;
        var initialAmountOfBombs = 20;
        var blockType = {
            type_empty: 0,
            type_wall: 1,
            type_crate: 2
        };
        var bombType = {
            type_basic: 0
        };
        var mapWidth = document.getElementById('cvs').width / blockSize;
        var mapHeight = document.getElementById('cvs').height / blockSize;
        var map = [];
        var Direction = {
            UP: 0,
            RIGHT: 1,
            DOWN: 2,
            LEFT: 3
        };
        var spawnPoints = [
            {
                X: 1,
                Y: 1
            },
            {
                X: 15,
                Y: 1
            },
            {
                X: 1,
                Y: 11
            },
            {
                X: 15,
                Y: 11
            }
        ];
        var reservedBlocks = [];
        var reservedBlocksInEachDirectionFromSpawnPoints = 2;
        var cratesPercentage = 0.7;
        var Players = [
            new Player(spawnPoints[0].X, spawnPoints[0].Y, 1, 'blue'),
            new Player(spawnPoints[1].X, spawnPoints[1].Y, 2, 'yellow')
        ];

        function makeMap() {

            for (var i = 0, x = 0, y = 0; i < mapWidth * mapHeight; i++) {

                if (x === mapWidth) {
                    x = 0;
                    y++;
                }
                if (x === 0 || y === 0 || x === mapWidth - 1 || y === mapHeight - 1 || x % 2 === 0 && y % 2 === 0) {
                    map.push({
                        MapPos: {
                            X: x,
                            Y: y
                        },
                        CanvasPos: {
                            X: Math.floor(x * blockSize),
                            Y: Math.floor(y * blockSize)
                        },
                        Size: {
                            Width: blockSize,
                            Height: blockSize
                        },
                        BlockType: {
                            blockType: blockType.type_wall
                        }
                    });
                }
                else {
                    map.push({
                        MapPos: {
                            X: x,
                            Y: y
                        },
                        CanvasPos: {
                            X: Math.floor(x * blockSize),
                            Y: Math.floor(y * blockSize)
                        },
                        Size: {
                            Width: blockSize,
                            Height: blockSize
                        },
                        BlockType: {
                            blockType: blockType.type_empty
                        },
                        HasBomb: false,
                        OnFire: false,
                        //SecondsOnFire: 0,
                        LetFireDieTimer: new Timer(),
                        CatchOnFire: function (x, y) {

                            //this.SecondsOnFire = this.SecondsOnFire + explosionTime;
                            var thisBlock = findBlock(x, y);

                            if (thisBlock.OnFire) {
                                //thisBlock.LetFireDieTimer.add(Date.now(), explosionTime);
                                clearTimeout(thisBlock.LetFireDieTimer.timeout);
                                thisBlock.LetFireDieTimer.start();
                            } else {
                                //thisBlock.LetFireDieTimer = new Timer(),
                                //thisBlock.LetFireDieTimer.isLoop = false;
                                thisBlock.LetFireDieTimer.interval = explosionTime;
                                thisBlock.LetFireDieTimer.tick = function () {
                                    thisBlock.OnFire = false;
                                }
                                thisBlock.OnFire = true;
                                thisBlock.LetFireDieTimer.start();
                            }

                            if (this.HasBomb) {

                                for (var i = 0; i < droppedBombs.length; i++) {

                                    if (droppedBombs[i].MapPos.X === x && droppedBombs[i].MapPos.Y === y) {
                                        
                                        droppedBombs[i].Explode(this.MapPos.X, this.MapPos.Y, droppedBombs[i].bombType, droppedBombs[i].Player);
                                        droppedBombs.splice(i, 1);
                                        
                                    }

                                }
                                
                            }

                            //for (var i = 0; i < this.SecondsOnFire + 1; i++) {

                            //    setTimeout(function () {

                            //        if (thisBlock.SecondsOnFire > 0) {
                            //            thisBlock.SecondsOnFire = thisBlock.SecondsOnFire - 1;
                                        
                            //        } else {
                            //            thisBlock.OnFire = false;
                            //        }

                            //    }, 1000)

                            //}
                            
                        }
                        
                    });
                }
                x++;
            }

        }

        function addReservedBlocks() {

            //Loop through spawnpoints
            for (var i = 0; i < spawnPoints.length; i++) {

                //Add spawnpoints to reservedBlocks[]
                reservedBlocks.push({
                    X: spawnPoints[i].X,
                    Y: spawnPoints[i].Y
                });

                var surroundings = returnSurroundings(spawnPoints[i].X, spawnPoints[i].Y, reservedBlocksInEachDirectionFromSpawnPoints);

                for (var j = 0; j < surroundings.Directions.length; j++) {

                    for (var k = 0; k < reservedBlocksInEachDirectionFromSpawnPoints; k++) {

                        if (surroundings.Directions[j][k] != null) {

                            reservedBlocks.push({
                                X: surroundings.Directions[j][k].MapPos.X,
                                Y: surroundings.Directions[j][k].MapPos.Y
                            });

                        }
                        
                    }

                }

            }

        }

        function findBlock(posX, posY) {

            for (var i = 0; i < map.length; i++) {

                if(posX === map[i].MapPos.X && posY === map[i].MapPos.Y) {

                    return map[i];
                    break;

                }

            }

        }

        function returnSurroundings(posX, posY, range) {

            var Surroundings = {

                Range: range,
                Center: findBlock(posX, posY),
                Directions: [
                    [],
                    [],
                    [],
                    []
                ]

            };

            for (var i = 0, d = 0, r = 1; i < 4 * range; i++) {

                if(i != 0 && i % range === 0) {
                    d++;
                }
                if (r === range + 1) {
                    r = 1;
                }
                switch(d) {
                    case 0: {
                        Surroundings.Directions[d].push(findBlock(Surroundings.Center.MapPos.X, Surroundings.Center.MapPos.Y - r));
                    } break;
                    case 1: {
                        Surroundings.Directions[d].push(findBlock(Surroundings.Center.MapPos.X + r, Surroundings.Center.MapPos.Y));
                    } break;
                    case 2: {
                        Surroundings.Directions[d].push(findBlock(Surroundings.Center.MapPos.X, Surroundings.Center.MapPos.Y + r));
                    } break;
                    case 3: {
                        Surroundings.Directions[d].push(findBlock(Surroundings.Center.MapPos.X - r, Surroundings.Center.MapPos.Y));
                    } break;
                }
                r++;

            };

            return Surroundings;

        }

        function generateCrates() {

            for (var i = 0; i < map.length; i++) {

                if (map[i].BlockType.blockType === blockType.type_empty) {

                    var isReserved = false;
                    for (var j = 0; j < reservedBlocks.length; j++) {

                        if (map[i].MapPos.X === reservedBlocks[j].X && map[i].MapPos.Y === reservedBlocks[j].Y) {

                            isReserved = true;
                            break;

                        }

                    }

                    if (!isReserved) {

                        if (Math.random() < cratesPercentage) {

                            map[i].BlockType.blockType = blockType.type_crate;

                        }

                    }

                }

            }

        }

        function drawMap() {

            for (var i = 0; i < map.length; i++) {
                if (map[i].BlockType.blockType === blockType.type_wall) {
                    ctx.fillStyle = "black";
                }
                else if (map[i].BlockType.blockType === blockType.type_empty) {
                    if (map[i].OnFire === true) {
                        ctx.fillStyle = "orange";
                    } else {
                        ctx.fillStyle = "green";
                    }
                }
                else if (map[i].BlockType.blockType === blockType.type_crate) {
                    ctx.fillStyle = "brown";
                }
                ctx.fillRect(map[i].MapPos.X * blockSize, map[i].MapPos.Y * blockSize, blockSize, blockSize);
            }

        }

        function drawPlayers() {

            for (var i = 0; i < Players.length; i++) {
                ctx.fillStyle = Players[i].playerColor;
                ctx.fillRect(Players[i].CanvasPos.X, Players[i].CanvasPos.Y, Players[i].Size.Width, Players[i].Size.Height);
                ctx.fillStyle = 'black';
            }

        }

        function drawBombs() {

            ctx.fillStyle = 'red';

            for (var j = 0; j < droppedBombs.length; j++){
                ctx.fillRect(droppedBombs[j].CanvasPos.X, droppedBombs[j].CanvasPos.Y, blockSize, blockSize);
            }

            ctx.fillStyle = 'black';

        }

        function newGame() {

            makeMap();
            addReservedBlocks();
            generateCrates();
            drawMap();
            drawPlayers();

        }

        function movePlayer(player) {

            posX = player.CanvasPos.X;
            posY = player.CanvasPos.Y;

            if (player.XKeys.right === true && player.XKeys.left === false) {
                player.CanvasPos.X = player.CanvasPos.X + player.playerSpeed;
            }
            else if (player.XKeys.right === false && player.XKeys.left === true) {
                player.CanvasPos.X = player.CanvasPos.X - player.playerSpeed;
            }

            if (player.YKeys.up === true && player.YKeys.down === false) {
                player.CanvasPos.Y = player.CanvasPos.Y - player.playerSpeed;
            }
            else if (player.YKeys.up === false && player.YKeys.down === true) {
                player.CanvasPos.Y = player.CanvasPos.Y + player.playerSpeed;
            }



            for (var i = 0; i < map.length; i++) {
                if (map[i].BlockType.blockType === blockType.type_wall || map[i].BlockType.blockType === blockType.type_crate) {
                    if (checkCollision(player, map[i])) {
                        player.CanvasPos.X = posX;
                        player.CanvasPos.Y = posY;
                    }
                } else {
                    player.MapPos.X = Math.floor(player.CanvasPos.X / blockSize);
                    player.MapPos.Y = Math.floor(player.CanvasPos.Y / blockSize);
                    continue;
                }
            }

        }

        function checkCollision(obj1, obj2) {

            if (obj1.CanvasPos.X < obj2.CanvasPos.X + obj2.Size.Width &&
                obj1.CanvasPos.X + obj1.Size.Width > obj2.CanvasPos.X &&
                obj1.CanvasPos.Y < obj2.CanvasPos.Y + obj2.Size.Height &&
                obj1.Size.Height + obj1.CanvasPos.Y > obj2.CanvasPos.Y) {

                return true;

            }
            else {
                return false;
            }

        }

        function isValidPlaceToLayBomb(x, y) {

            var isValid = true;

            for (var j = 0; j < droppedBombs.length; j++) {

                if (x === droppedBombs[j].MapPos.X && y === droppedBombs[j].MapPos.Y) {

                    isValid = false;

                }

            }
            
            return isValid;
        }

        newGame();

        timer.tick = function () {

            for (var i = 0; i < Players.length; i++) {
                movePlayer(Players[i]);
            }

            ctx.clearRect(0, 0, c.width, c.height);
            drawMap();
            drawBombs();
            drawPlayers();
        };

        $(document).keydown(function (e) {

            switch (e.keyCode) {

/*ENTER*/           case 13: {
                        if (timer.stopped) {
                            timer.start();
                        } else {
                            timer.stop();
                        }
                    } break;

/*Player 1*/

/*W*/               case 87: {
                        Players[0].YKeys.up = true;
                        Players[0].currentDirection = Direction.UP;
                    } break;

/*D*/               case 68: {
                        Players[0].XKeys.right = true;
                        Players[0].currentDirection = Direction.RIGHT;
                    } break;

/*S*/               case 83: {
                        Players[0].YKeys.down = true;
                        Players[0].currentDirection = Direction.DOWN;
                    } break;

/*A*/               case 65: {
                        Players[0].XKeys.left = true;
                        Players[0].currentDirection = Direction.LEFT;
                    } break;
/*SPACE*/           case 32: {
                        if (!timer.stopped) {

                            if (Players[0].amountOfBombs > 0) {

                                if (isValidPlaceToLayBomb(Players[0].MapPos.X, Players[0].MapPos.Y)) {

                                    Players[0].amountOfBombs = Players[0].amountOfBombs - 1;
                                    Players[0].dropBomb(Players[0].MapPos.X, Players[0].MapPos.Y, Players[1].equippedBomb, Players[0]);

                                    setTimeout(function () {
                                        droppedBombs.shift();
                                    }, explosionTime);

                                }

                            } 

                        }
                    } break;

/*Player 2*/

/*UP*/              case 38: {
                        Players[1].YKeys.up = true;
                        Players[1].currentDirection = Direction.UP;
                    } break;

/*RIGHT*/           case 39: {
                        Players[1].XKeys.right = true;
                        Players[1].currentDirection = Direction.RIGHT;
                    } break;

/*DOWN*/            case 40: {
                        Players[1].YKeys.down = true;
                        Players[1].currentDirection = Direction.DOWN;
                    } break;

/*LEFT*/            case 37: {
                        Players[1].XKeys.left = true;
                        Players[1].currentDirection = Direction.LEFT;
                    } break;
/*FORWARD SLASH*/   case 191: {
                        if (!timer.stopped) {

                            if (Players[1].amountOfBombs > 0) {

                                if (isValidPlaceToLayBomb(Players[1].MapPos.X, Players[1].MapPos.Y)) {

                                    Players[1].amountOfBombs = Players[1].amountOfBombs - 1;
                                    Players[1].dropBomb(Players[1].MapPos.X, Players[1].MapPos.Y, Players[1].equippedBomb, Players[1]);

                                    setTimeout(function () {
                                        droppedBombs.shift();
                                    }, explosionTime);

                                }

                            } 
                                
                        }
                    } break;

            }

        });

        $(document).keyup(function (e) {

            switch (e.keyCode) {

/*Player 1*/

/*W*/           case 87: {
                    Players[0].YKeys.up = false;
                } break;

/*D*/           case 68: {
                    Players[0].XKeys.right = false;
                } break;

/*S*/           case 83: {
                    Players[0].YKeys.down = false;
                } break;

/*A*/           case 65: {
                    Players[0].XKeys.left = false;
                } break;

/*Player 2*/

/*UP*/          case 38: {
                    Players[1].YKeys.up = false;
                } break;

/*RIGHT*/       case 39: {
                    Players[1].XKeys.right = false;
                } break;

/*DOWN*/        case 40: {
                    Players[1].YKeys.down = false;
                } break;

/*LEFT*/        case 37: {
                    Players[1].XKeys.left = false;
                } break;

            }

        });

        function Player(x, y, id, color) {

            this.MapPos = {
                X: x,
                Y: y
            },
            this.CanvasPos = {
                X: Math.floor(x * blockSize),
                Y: Math.floor(y * blockSize)
            },
            this.Size = {
                Width: playerSize,
                Height: playerSize
            },
            this.XKeys = {
                right: false,
                left: false
            },
            this.YKeys = {
                up: false,
                down: false
            },
            this.playerID = id,
            this.playerColor = color,
            this.playerSpeed = 1,
            this.health = initialHealth;
            this.currentDirection = Direction.RIGHT,
            this.amountOfBombs = initialAmountOfBombs,
            this.explosionRange = initialBombRange,
            this.equippedBomb = bombType.type_basic;
            this.dropBomb = function (x, y, bombType, player) {

                droppedBombs.push(new Bomb(x, y, bombType, player));
                findBlock(x, y).HasBomb = true;

                setTimeout(function () {
                    if (droppedBombs.length > 0) {
                        droppedBombs[0].Explode(x, y, bombType, player);
                    }
                }, explosionTime);

            }

        }

        function Bomb(mapPosX, mapPosY, bombType, player) {

            this.Player = player,
            this.Type = bombType,
            this.MapPos = {
                X: mapPosX,
                Y: mapPosY
            },
            this.CanvasPos = {
                X: Math.floor(mapPosX * blockSize),
                Y: Math.floor(mapPosY * blockSize)
            },
            this.Size = {
                Width: blockSize,
                Height: blockSize
            },
            this.Damage = 1,
            //this.Radius = initialBombRadius,
            this.Explode = function (x, y, bombType, player) {

                findBlock(x, y).HasBomb = false;
                player.amountOfBombs = player.amountOfBombs + 1;
                var explosionRadius = returnSurroundings(x, y, player.explosionRange);
                explosionRadius.Center.CatchOnFire(x, y);
                
                for (var i = 0; i < explosionRadius.Directions.length; i++) {

                    for (var j = 0; j < explosionRadius.Directions[i].length; j++) {

                        if (explosionRadius.Directions[i][j] != null) {

                            if (explosionRadius.Directions[i][j].BlockType.blockType === blockType.type_empty) {

                                explosionRadius.Directions[i][j].CatchOnFire(explosionRadius.Directions[i][j].MapPos.X, explosionRadius.Directions[i][j].MapPos.Y);

                            } else if (explosionRadius.Directions[i][j].BlockType.blockType === blockType.type_crate) {

                                explosionRadius.Directions[i][j].BlockType.blockType = blockType.type_empty;
                                explosionRadius.Directions[i][j].CatchOnFire(explosionRadius.Directions[i][j].MapPos.X, explosionRadius.Directions[i][j].MapPos.Y);
                                break;

                            } else if (explosionRadius.Directions[i][j].BlockType.blockType === blockType.type_wall) {

                                break;

                            }

                        }

                    }

                }
                

                //setTimeout(function () {
                //    for (var i = 0; i < onFireBlocks.length; i++) {
                //        onFireBlocks[i].OnFire = false;
                //    }
                //    onFireBlocks = [];
                //    console.log(onFireBlocks);
                //}, explosionTime);
                
                //console.log(explosionRadius);
                //console.log("Bomb exploded at X: " + x, "Y: " + y);
            }

        }

        //function updateSections(player) {
        //    player.Sections = {
        //        UpLeft: {
        //            CanvasPos: {
        //                X: player.CanvasPos.X,
        //                Y: player.CanvasPos.Y
        //            },
        //            Size: {
        //                Width: blockSize / 2,
        //                Height: blockSize / 2
        //            }
        //        },
        //        UpRight: {
        //            CanvasPos: {
        //                X: player.CanvasPos.X + blockSize / 2,
        //                Y: player.CanvasPos.Y
        //            },
        //            Size: {
        //                Width: blockSize / 2,
        //                Height: blockSize / 2
        //            }
        //        },
        //        DownLeft: {
        //            CanvasPos: {
        //                X: player.CanvasPos.X,
        //                Y: player.CanvasPos.Y + blockSize / 2
        //            },
        //            Size: {
        //                Width: blockSize / 2,
        //                Height: blockSize / 2
        //            }
        //        },
        //        DownRight: {
        //            CanvasPos: {
        //                X: player.CanvasPos.X + blockSize / 2,
        //                Y: player.CanvasPos.Y + blockSize / 2
        //            },
        //            Size: {
        //                Width: blockSize / 2,
        //                Height: blockSize / 2
        //            }
        //        }
        //    };
        //}

        //function Timer(callback, time) {
        //    this.setTimeout(callback, time);
        //}

        //Timer.prototype.setTimeout = function (callback, time) {
        //    var self = this;
        //    if (this.timer) {
        //        clearTimeout(this.timer);
        //    }
        //    this.finished = false;
        //    this.callback = callback;
        //    this.time = time;
        //    this.timer = setTimeout(function () {
        //        self.finished = true;
        //        callback();
        //    }, time);
        //    this.start = Date.now();
        //}

        //Timer.prototype.add = function (time) {
        //    if (!this.finished) {
        //        // add time to time left
        //        time = this.time - (Date.now() - this.start) + time;
        //        this.setTimeout(this.callback, time);
        //    }
        //}

        function Timer() {

            this.interval = 0;
            this.stopped = true;
            this.timeout;
            this.timeStarted;
            this.isLoop = false;
            this.tick = function () { }
            this.ticki = function () {

                if (!self.stopped) {

                    self.tick();

                    if (self.isLoop) {
                        self.continue();
                    } else {
                        self.stopped = true;
                    }

                }

            }
            this.start = function () {
                self.timeStarted = Date.now();
                self.stopped = false;
                self.continue();
            }
            this.continue = function () {
                self.timeout = setTimeout(self.ticki, self.interval);
            }
            this.stop = function () {
                self.stopped = true;
            }
            this.add = function (now, time) {
                //console.log(self.interval - (Date.now() - self.timeStarted) + time);
                var newTime = self.interval - (now - self.timeStarted) + time;
                
                clearTimeout(self.timeout);
                self.timeout = setTimeout(self.ticki, newTime);
            }
            var self = this;

        }

    </script>
</body>
</html>
