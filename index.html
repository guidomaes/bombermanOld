<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <title>Bomberman</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

</head>
<body style="background-color: black;">

    <canvas id="cvs" width="680" height="520"></canvas>

    <script>

        var c = document.getElementById('cvs');
        var ctx = c.getContext('2d');
        var timer = new Timer();
        timer.Interval = 10;
        var blockSize = 40;
        var blockType = {
            type_empty: 0,
            type_wall: 1,
            type_crate: 2
        };
        var mapWidth = document.getElementById('cvs').width / blockSize;
        var mapHeight = document.getElementById('cvs').height / blockSize;
        var map = [];
        var Direction = {
            UP: 0,
            RIGHT: 1,
            DOWN: 2,
            LEFT: 3
        };
        var spawnPoints = [
            {
                X: 40,
                Y: 40
            },
            {
                X: 600,
                Y: 40
            },
            {
                X: 40,
                Y: 440
            },
            {
                X: 600,
                Y: 440
            }
        ];
        var reservedBlocks = [];
        var reservedBlocksPercentage = 0.7;
        var Players = [
            new Player(spawnPoints[0].X, spawnPoints[0].Y, 1, 'blue'),
            new Player(spawnPoints[1].X, spawnPoints[1].Y, 2, 'red')
        ];

        function makeMap() {

            for (var i = 0, x = 0, y = 0; i < mapWidth * mapHeight; i++) {

                if (x === mapWidth) {
                    x = 0;
                    y++;
                }
                if (x === 0 || y === 0 || x === mapWidth - 1 || y === mapHeight - 1 || x % 2 === 0 && y % 2 === 0) {
                    map.push({
                        MapPos: {
                            X: x,
                            Y: y
                        },
                        CanvasPos: {
                            X: Math.floor(x * blockSize),
                            Y: Math.floor(y * blockSize)
                        },
                        Size: {
                            Width: blockSize,
                            Height: blockSize
                        },
                        BlockType: {
                            blockType: blockType.type_wall
                        }
                    });
                }
                else {
                    map.push({
                        MapPos: {
                            X: x,
                            Y: y
                        },
                        CanvasPos: {
                            X: Math.floor(x * blockSize),
                            Y: Math.floor(y * blockSize)
                        },
                        Size: {
                            Width: blockSize,
                            Height: blockSize
                        },
                        BlockType: {
                            blockType: blockType.type_empty
                        }
                    });
                }
                x++;
            }

        }

        function addReservedBlocks() {

            //Loop through spawnpoints
            for (var i = 0; i < spawnPoints.length; i++) {

                //Add spawnpoints to reservedBlocks[]
                reservedBlocks.push({
                    X: spawnPoints[i].X,
                    Y: spawnPoints[i].Y
                });

                for (var j = 0; j < map.length; j++) {

                    //Check if map values match spawnpoints values
                    if (map[j].CanvasPos.X === spawnPoints[i].X && map[j].CanvasPos.Y === spawnPoints[i].Y) {

                        for (var h = 0; h < map.length; h++) {
                            
                            //Check for the block above the spawnpoint
                            if (map[j].CanvasPos.X === map[h].CanvasPos.X && map[j].CanvasPos.Y - 40 === map[h].CanvasPos.Y) {

                                //If the block above the spawnpoint is an empty block, add that block and the one above that to reservedBlocks[]
                                if (map[h].BlockType.blockType === blockType.type_empty) {

                                    reservedBlocks.push(
                                        {
                                            X: map[h].CanvasPos.X,
                                            Y: map[h].CanvasPos.Y
                                        },
                                        {
                                            X: map[h].CanvasPos.X,
                                            Y: map[h].CanvasPos.Y - 40
                                        }
                                    );

                                }

                            }

                            //Check for the block above the spawnpoint
                            if (map[j].CanvasPos.X + 40 === map[h].CanvasPos.X && map[j].CanvasPos.Y === map[h].CanvasPos.Y) {

                                //If the block right from the spawnpoint is an empty block, add that block and the one right to that reservedBlocks[]
                                if (map[h].BlockType.blockType === blockType.type_empty) {

                                    reservedBlocks.push(
                                        {
                                            X: map[h].CanvasPos.X,
                                            Y: map[h].CanvasPos.Y
                                        },
                                        {
                                            X: map[h].CanvasPos.X + 40,
                                            Y: map[h].CanvasPos.Y
                                        }
                                    );

                                }

                            }

                            //Check for the block above the spawnpoint
                            if (map[j].CanvasPos.X === map[h].CanvasPos.X && map[j].CanvasPos.Y + 40 === map[h].CanvasPos.Y) {

                                //If the block below the spawnpoint is an empty block, add that block and the one below that to reservedBlocks[]
                                if (map[h].BlockType.blockType === blockType.type_empty) {

                                    reservedBlocks.push(
                                        {
                                            X: map[h].CanvasPos.X,
                                            Y: map[h].CanvasPos.Y
                                        },
                                        {
                                            X: map[h].CanvasPos.X,
                                            Y: map[h].CanvasPos.Y + 40
                                        }
                                    );

                                }

                            }

                            //Check for the block above the spawnpoint
                            if (map[j].CanvasPos.X - 40 === map[h].CanvasPos.X && map[j].CanvasPos.Y === map[h].CanvasPos.Y) {

                                //If the block left from the spawnpoint is an empty block, add that block and the one left to that to reservedBlocks[]
                                if (map[h].BlockType.blockType === blockType.type_empty) {

                                    reservedBlocks.push(
                                        {
                                            X: map[h].CanvasPos.X,
                                            Y: map[h].CanvasPos.Y
                                        },
                                        {
                                            X: map[h].CanvasPos.X - 40,
                                            Y: map[h].CanvasPos.Y
                                        }
                                    );

                                }

                            }

                        }

                    }

                }
                
            }

        }

        function generateCrates() {

            for (var i = 0; i < map.length; i++) {

                if (map[i].BlockType.blockType === blockType.type_empty) {

                    var isReserved = false;
                    for (var j = 0; j < reservedBlocks.length; j++) {

                        if (map[i].CanvasPos.X === reservedBlocks[j].X && map[i].CanvasPos.Y === reservedBlocks[j].Y) {

                            isReserved = true;
                            break;

                        }

                    }

                    if (!isReserved) {

                        if (Math.random() < reservedBlocksPercentage) {

                            map[i].BlockType.blockType = blockType.type_crate;

                        }

                    }

                }

            }

        }

        function drawMap() {

            for (var i = 0; i < map.length; i++) {
                if (map[i].BlockType.blockType === blockType.type_wall) {
                    ctx.fillStyle = "black";
                }
                else if (map[i].BlockType.blockType === blockType.type_empty) {
                    ctx.fillStyle = "green";
                }
                else if (map[i].BlockType.blockType === blockType.type_crate) {
                    ctx.fillStyle = "brown";
                }
                ctx.fillRect(map[i].MapPos.X * blockSize, map[i].MapPos.Y * blockSize, blockSize, blockSize);
            }

        }

        function drawPlayers() {

            for (var i = 0; i < Players.length; i++) {
                ctx.fillStyle = Players[i].playerColor;
                ctx.fillRect(Players[i].CanvasPos.X, Players[i].CanvasPos.Y, Players[i].Size.Width, Players[i].Size.Height);
                ctx.fillStyle = 'black';
            }

        }

        function drawspawnPoints() {
            ctx.fillStyle = 'yellow';
            for (var i = 0; i < reservedBlocks.length; i++) {
                ctx.fillRect(reservedBlocks[i].X, reservedBlocks[i].Y, blockSize, blockSize);
            }
            ctx.fillStyle = 'black';
        }

        function newGame() {
            makeMap();
            addReservedBlocks();
            generateCrates();
            drawMap();
            //drawspawnPoints();
            drawPlayers();
            
        }

        function movePlayer(player) {

            posX = player.CanvasPos.X;
            posY = player.CanvasPos.Y;
            
            if (player.XKeys.right === true && player.XKeys.left === false) {
                player.CanvasPos.X = player.CanvasPos.X + player.playerSpeed;
            }
            else if (player.XKeys.right === false && player.XKeys.left === true) {
                player.CanvasPos.X = player.CanvasPos.X - player.playerSpeed;
            }

            if (player.YKeys.up === true && player.YKeys.down === false) {
                player.CanvasPos.Y = player.CanvasPos.Y - player.playerSpeed;
            }
            else if (player.YKeys.up === false && player.YKeys.down === true) {
                player.CanvasPos.Y = player.CanvasPos.Y + player.playerSpeed;
            }

            

            for (var i = 0; i < map.length; i++) {
                if (map[i].BlockType.blockType === blockType.type_wall) {
                    if (checkCollision(player, map[i])) {
                        player.CanvasPos.X = posX;
                        player.CanvasPos.Y = posY;
                    }
                } else {
                    continue;
                }
            }

        }

        function checkCollision(obj1, obj2) {

            if (obj1.CanvasPos.X < obj2.CanvasPos.X + obj2.Size.Width &&
                obj1.CanvasPos.X + obj1.Size.Width > obj2.CanvasPos.X &&
                obj1.CanvasPos.Y < obj2.CanvasPos.Y + obj2.Size.Height &&
                obj1.Size.Height + obj1.CanvasPos.Y > obj2.CanvasPos.Y) {

                return true;

            }
            else {
                return false;
            }

        }

        //function calculateSupposedPosition(player, x, y) {

        //    this.CanvasPos = {
        //        X: player.CanvasPos.X + x,
        //        Y: player.CanvasPos.Y + y
        //    };

        //    this.Size = {
        //        Width: blockSize,
        //        Height: blockSize
        //    };

        //    this.Sections = {};

        //}

        newGame();


        timer.Tick = function () {

            for (var i = 0; i < Players.length; i++) {
                movePlayer(Players[i]);
            }
            //for (var i = 0; i < Players.length; i++) {

            //    if (Players[i].keyPressed === true) {

            //        switch (Players[i].currentDirection) {

            //            case Direction.UP:
            //            {

            //                    //var supposedPosition = new calculateSupposedPosition(Players[i], 0, -Players[i].playerSpeed);

            //                    //updateSections(supposedPosition);

            //                    //for (var p = 0; p < map.length; p++) {

            //                    //    if (map[p].BlockType.blockType === blockType.type_wall && checkCollision(supposedPosition, map[p])) {
            //                    //        if (checkCollision(supposedPosition.Sections.UpLeft, map[p]) && !checkCollision(supposedPosition.Sections.UpRight, map[p])) {
            //                    //            Players[i].CanvasPos.X += Players[i].playerSpeed;
            //                    //            Players[i].MapPos.X = Math.floor(Players[i].CanvasPos.X / blockSize);
            //                    //            updateSections(Players[i]);
            //                    //        }
            //                    //        else if (!checkCollision(supposedPosition.Sections.UpLeft, map[p]) && checkCollision(supposedPosition.Sections.UpRight, map[p])) {
            //                    //            Players[i].CanvasPos.X -= Players[i].playerSpeed;
            //                    //            Players[i].MapPos.X = Math.floor(Players[i].CanvasPos.X / blockSize);
            //                    //            updateSections(Players[i]);
            //                    //        }
            //                    //        else {
            //                    //            break;
            //                    //        }

            //                    //    }
            //                    //    if (p === map.length - 1) {
            //                    //        Players[i].CanvasPos.Y -= Players[i].playerSpeed;
            //                    //        Players[i].MapPos.Y = Math.floor(Players[i].CanvasPos.Y / blockSize);
            //                    //        updateSections(Players[i]);
            //                    //    }

            //                    //}

            //                    Players[i].CanvasPos.Y -= Players[i].playerSpeed;
            //                    Players[i].MapPos.Y = Math.floor(Players[i].CanvasPos.Y / blockSize);

            //            } break;
            //            case Direction.RIGHT:
            //            {

            //                    //var supposedPosition = new calculateSupposedPosition(Players[i], Players[i].playerSpeed, 0);

            //                    //updateSections(supposedPosition);

            //                    //for (var p = 0; p < map.length; p++) {

            //                    //    if (map[p].BlockType.blockType === blockType.type_wall && checkCollision(supposedPosition, map[p])) {
            //                    //        if (checkCollision(supposedPosition.Sections.UpRight, map[p]) && !checkCollision(supposedPosition.Sections.DownRight, map[p])) {
            //                    //            Players[i].CanvasPos.Y += Players[i].playerSpeed;
            //                    //            Players[i].MapPos.Y = Math.floor(Players[i].CanvasPos.X / blockSize);
            //                    //            updateSections(Players[i]);
            //                    //        }
            //                    //        else if (!checkCollision(supposedPosition.Sections.UpRight, map[p]) && checkCollision(supposedPosition.Sections.DownRight, map[p])) {
            //                    //            Players[i].CanvasPos.Y -= Players[i].playerSpeed;
            //                    //            Players[i].MapPos.Y = Math.floor(Players[i].CanvasPos.X / blockSize);
            //                    //            updateSections(Players[i]);
            //                    //        }
            //                    //        else {
            //                    //            break;
            //                    //        }
            //                    //    }
            //                    //    if (p === map.length - 1) {
            //                    //        Players[i].CanvasPos.X += Players[i].playerSpeed;
            //                    //        Players[i].MapPos.X = Math.floor(Players[i].CanvasPos.X / blockSize);
            //                    //        updateSections(Players[i]);
            //                    //    }

            //                    //}

            //                    Players[i].CanvasPos.X += Players[i].playerSpeed;
            //                    Players[i].MapPos.X = Math.floor(Players[i].CanvasPos.X / blockSize);

            //            } break;
            //            case Direction.DOWN:
            //            {

            //                    //var supposedPosition = new calculateSupposedPosition(Players[i], 0, Players[i].playerSpeed);

            //                    //updateSections(supposedPosition);

            //                    //for (var p = 0; p < map.length; p++) {

            //                    //    if (map[p].BlockType.blockType === blockType.type_wall && checkCollision(supposedPosition, map[p])) {
            //                    //        if (checkCollision(supposedPosition.Sections.DownRight, map[p]) && !checkCollision(supposedPosition.Sections.DownLeft, map[p])) {
            //                    //            Players[i].CanvasPos.X -= Players[i].playerSpeed;
            //                    //            Players[i].MapPos.X = Math.floor(Players[i].CanvasPos.X / blockSize);
            //                    //            updateSections(Players[i]);
            //                    //        }
            //                    //        else if (!checkCollision(supposedPosition.Sections.DownRight, map[p]) && checkCollision(supposedPosition.Sections.DownLeft, map[p])) {
            //                    //            Players[i].CanvasPos.X += Players[i].playerSpeed;
            //                    //            Players[i].MapPos.X = Math.floor(Players[i].CanvasPos.X / blockSize);
            //                    //            updateSections(Players[i]);
            //                    //        }
            //                    //        else {
            //                    //            break;
            //                    //        }
            //                    //    }
            //                    //    if (p === map.length - 1) {
            //                    //        Players[i].CanvasPos.Y += Players[i].playerSpeed;
            //                    //        Players[i].MapPos.Y = Math.floor(Players[i].CanvasPos.Y / blockSize);
            //                    //        updateSections(Players[i]);
            //                    //    }

            //                    //}

            //                    Players[i].CanvasPos.Y += Players[i].playerSpeed;
            //                    Players[i].MapPos.Y = Math.floor(Players[i].CanvasPos.Y / blockSize);

            //            } break;
            //            case Direction.LEFT:
            //            {

            //                    //var supposedPosition = new calculateSupposedPosition(Players[i], -Players[i].playerSpeed, 0);

            //                    //updateSections(supposedPosition);

            //                    //for (var p = 0; p < map.length; p++) {

            //                    //    if (map[p].BlockType.blockType === blockType.type_wall && checkCollision(supposedPosition, map[p])) {
            //                    //        if (checkCollision(supposedPosition.Sections.UpLeft, map[p]) && !checkCollision(supposedPosition.Sections.DownLeft, map[p])) {
            //                    //            Players[i].CanvasPos.Y += Players[i].playerSpeed;
            //                    //            Players[i].MapPos.Y = Math.floor(Players[i].CanvasPos.X / blockSize);
            //                    //            updateSections(Players[i]);
            //                    //        }
            //                    //        else if (!checkCollision(supposedPosition.Sections.UpLeft, map[p]) && checkCollision(supposedPosition.Sections.DownLeft, map[p])) {
            //                    //            Players[i].CanvasPos.Y -= Players[i].playerSpeed;
            //                    //            Players[i].MapPos.Y = Math.floor(Players[i].CanvasPos.X / blockSize);
            //                    //            updateSections(Players[i]);
            //                    //        }
            //                    //        else {
            //                    //            break;
            //                    //        }
            //                    //    }
            //                    //    if (p === map.length - 1) {
            //                    //        Players[i].CanvasPos.X -= Players[i].playerSpeed;
            //                    //        Players[i].MapPos.X = Math.floor(Players[i].CanvasPos.X / blockSize);
            //                    //        updateSections(Players[i]);
            //                    //    }

            //                    //}

            //                    Players[i].CanvasPos.X -= Players[i].playerSpeed;
            //                    Players[i].MapPos.X = Math.floor(Players[i].CanvasPos.X / blockSize);

            //            } break;

            //        }

            //    }

            //}

            ctx.clearRect(0, 0, c.width, c.height);
            drawMap();
            drawPlayers();
            //drawspawnPoints();
            



        };



        //$(document).keydown(function (e) {

        //    switch (e.keyCode) {


        //        ///*W*/           case 87: {
        //        //                    if (!timer.stopped) {
        //        //                        Players[0].currentDirection = Direction.UP;
        //        //                        document.getElementById('demo').innerHTML = Players[0].currentDirection;
        //        //                    }
        //        //                } break;
        //        ///*D*/           case 68: {
        //        //                    if (!timer.stopped) {
        //        //                        Players[0].currentDirection = Direction.RIGHT;
        //        //                        document.getElementById('demo').innerHTML = Players[0].currentDirection;
        //        //                    }
        //        //                } break;
        //        ///*S*/           case 83: {
        //        //                    if (!timer.stopped) {
        //        //                        Players[0].currentDirection = Direction.DOWN;
        //        //                        document.getElementById('demo').innerHTML = Players[0].currentDirection;
        //        //                    }
        //        //                } break;
        //        ///*A*/           case 65: {
        //        //                    if (!timer.stopped) {
        //        //                        Players[0].currentDirection = Direction.LEFT;
        //        //                        document.getElementById('demo').innerHTML = Players[0].currentDirection;
        //        //                    }
        //        //                } break;
        //        ///*UP*/          case 38: {
        //        //                    if (!timer.stopped) {
        //        //                        Players[1].currentDirection = Direction.UP;
        //        //                    }
        //        //                } break;
        //        ///*RIGHT*/       case 39: {
        //        //                    if (!timer.stopped) {
        //        //                        Players[1].currentDirection = Direction.RIGHT;
        //        //                    }
        //        //                } break;
        //        ///*DOWN*/        case 40: {
        //        //                    if (!timer.stopped) {
        //        //                        Players[1].currentDirection = Direction.DOWN;
        //        //                    }
        //        //                } break;
        //        ///*LEFT*/        case 37: {
        //        //                    if (!timer.stopped) {
        //        //                        Players[1].currentDirection = Direction.LEFT;
        //        //                    }
        //        //                } break;
        //    }

        //});

        $(document).keydown(function (e) {

            switch (e.keyCode) {

/*ENTER*/           case 13: {
                        if (timer.stopped) {
                            timer.Start();
                        } else {
                            timer.Stop();
                        }
                    } break;

/*Player 1*/

/*W*/               case 87: {
                        Players[0].YKeys.up = true;
                        Players[0].currentDirection = Direction.UP;
                    } break;

/*D*/               case 68: {
                        Players[0].XKeys.right = true;
                        Players[0].currentDirection = Direction.RIGHT;
                    } break;

/*S*/               case 83: {
                        Players[0].YKeys.down = true;
                        Players[0].currentDirection = Direction.DOWN;
                    } break;

/*A*/               case 65: {
                        Players[0].XKeys.left = true;
                        Players[0].currentDirection = Direction.LEFT;
                    } break;

/*Player 2*/

/*UP*/              case 38: {
                        Players[1].YKeys.up = true;
                        Players[1].currentDirection = Direction.UP;
                    } break;

/*RIGHT*/           case 39: {
                        Players[1].XKeys.right = true;
                        Players[1].currentDirection = Direction.RIGHT;
                    } break;

/*DOWN*/            case 40: {
                        Players[1].YKeys.down = true; 
                        Players[1].currentDirection = Direction.DOWN;
                    } break;

/*LEFT*/            case 37: {
                        Players[1].XKeys.left = true;
                        Players[1].currentDirection = Direction.LEFT;
                    } break;

            }

        });

        $(document).keyup(function (e) {

            switch (e.keyCode) {

/*Player 1*/

/*W*/           case 87: {
                    Players[0].YKeys.up = false;
                } break;
                
/*D*/           case 68: {
                    Players[0].XKeys.right = false;
                } break;
                
/*S*/           case 83: {
                    Players[0].YKeys.down = false;
                } break;
                
/*A*/           case 65: {
                    Players[0].XKeys.left = false;
                } break;

/*Player 2*/

/*UP*/          case 38: {
                    Players[1].YKeys.up = false;
                } break;

/*RIGHT*/       case 39: {
                    Players[1].XKeys.right = false;
                } break;

/*DOWN*/        case 40: {
                    Players[1].YKeys.down = false;
                } break;

/*LEFT*/        case 37: {
                    Players[1].XKeys.left = false;
                } break;

            }

        });

        function Player(x, y, number, color) {

            this.MapPos = {
                X: Math.floor(x / blockSize),
                Y: Math.floor(y / blockSize)
            },
            this.CanvasPos = {
                X: x,
                Y: y
            },
            this.Size = {
                Width: 30,
                Height: 30
            },
            this.XKeys = {
                right: false,
                left: false
            },
            this.YKeys = {
                up: false,
                down: false
            },
            this.Number = number,
            this.playerColor = color,
            this.playerSpeed = 1,
            this.currentDirection = Direction.RIGHT

        }

        //function updateSections(player) {
        //    player.Sections = {
        //        UpLeft: {
        //            CanvasPos: {
        //                X: player.CanvasPos.X,
        //                Y: player.CanvasPos.Y
        //            },
        //            Size: {
        //                Width: blockSize / 2,
        //                Height: blockSize / 2
        //            }
        //        },
        //        UpRight: {
        //            CanvasPos: {
        //                X: player.CanvasPos.X + blockSize / 2,
        //                Y: player.CanvasPos.Y
        //            },
        //            Size: {
        //                Width: blockSize / 2,
        //                Height: blockSize / 2
        //            }
        //        },
        //        DownLeft: {
        //            CanvasPos: {
        //                X: player.CanvasPos.X,
        //                Y: player.CanvasPos.Y + blockSize / 2
        //            },
        //            Size: {
        //                Width: blockSize / 2,
        //                Height: blockSize / 2
        //            }
        //        },
        //        DownRight: {
        //            CanvasPos: {
        //                X: player.CanvasPos.X + blockSize / 2,
        //                Y: player.CanvasPos.Y + blockSize / 2
        //            },
        //            Size: {
        //                Width: blockSize / 2,
        //                Height: blockSize / 2
        //            }
        //        }
        //    };
        //}



        function Timer() {

            this.Interval = 0;
            this.stopped = true;
            this.Tick = function () { };
            this.ticki = function () {
                if (!self.stopped) {
                    self.Tick();
                    self.continue();
                }
            };
            this.Start = function () {
                self.stopped = false;
                self.continue();
            };
            this.continue = function () {
                setTimeout(this.ticki, this.Interval);
            };
            this.Stop = function () {
                self.stopped = true;
            };
            var self = this;

        }

    </script>
</body>
</html>
