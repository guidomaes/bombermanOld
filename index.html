<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
	<script src="jquery-3.3.1.min.js"></script>
	
    <title>Bomberman</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

</head>
<body style="background-color: black;">

    <canvas id="cvs" width="680" height="520"></canvas>

    <script>

        var c = document.getElementById('cvs');
        var ctx = c.getContext('2d');
        var timer = new Timer();
        timer.interval = 30;
        timer.isLoop = true;
        var blockSize = 40;
        var playerSize = 20;
        var explosionTime = 2500;
        var onFireTime = 1500;
        var initialHealth = 3;
        var initialBombRange = 2;
        var initialAmountOfBombs = 20;
        var initialPlayerSpeed = 2;
        var blockType = {
            type_empty: 0,
            type_wall: 1,
            type_crate: 2
        };
        var bombType = {
            type_basic: 0
        };
        var mapWidth = document.getElementById('cvs').width / blockSize;
        var mapHeight = document.getElementById('cvs').height / blockSize;
        var map = [];
        var Direction = {
            UP: 0,
            RIGHT: 1,
            DOWN: 2,
            LEFT: 3
        };
        var spawnPoints = [
            {
                X: 1,
                Y: 1
            },
            {
                X: 15,
                Y: 1
            },
            {
                X: 1,
                Y: 11
            },
            {
                X: 15,
                Y: 11
            }
        ];
        var reservedBlocks = [];
        var reservedBlocksInEachDirectionFromSpawnPoints = 2;
        var cratesPercentage = 0.7;
        var Players = [
            new Player(spawnPoints[0].X, spawnPoints[0].Y, 1, 'blue'),
            new Player(spawnPoints[1].X, spawnPoints[1].Y, 2, 'yellow')
        ];

        function makeMap() {

            for (var i = 0, x = 0, y = 0; i < mapWidth * mapHeight; i++) {

                if (x === mapWidth) {
                    x = 0;
                    y++;
                }
                if (x === 0 || y === 0 || x === mapWidth - 1 || y === mapHeight - 1 || x % 2 === 0 && y % 2 === 0) {
                    map.push({
                        MapPos: {
                            X: x,
                            Y: y
                        },
                        CanvasPos: {
                            X: Math.floor(x * blockSize),
                            Y: Math.floor(y * blockSize)
                        },
                        Size: {
                            Width: blockSize,
                            Height: blockSize
                        },
                        BlockType: {
                            blockType: blockType.type_wall
                        }
                    });
                }
                else {
                    map.push({
                        MapPos: {
                            X: x,
                            Y: y
                        },
                        CanvasPos: {
                            X: Math.floor(x * blockSize),
                            Y: Math.floor(y * blockSize)
                        },
                        Size: {
                            Width: blockSize,
                            Height: blockSize
                        },
                        BlockType: {
                            blockType: blockType.type_empty
                        },
                        HasBomb: false,
                        Bomb: null,
                        OnFire: false,
                        LetFireDieTimer: new Timer(),
                        CatchOnFire: function (x, y, player) {

                            var thisBlock = findBlock(x, y);

                            if (thisBlock.OnFire) {
                                clearTimeout(thisBlock.LetFireDieTimer.timeout);
                                thisBlock.LetFireDieTimer.start();
                            } else {
                                thisBlock.LetFireDieTimer.interval = onFireTime;
                                thisBlock.LetFireDieTimer.tick = function () {
                                    thisBlock.OnFire = false;
                                }
                                thisBlock.OnFire = true;
                                thisBlock.LetFireDieTimer.start();
                            }

                        }
                        
                    });
                }
                x++;
            }

        }

        function addReservedBlocks() {

            //Loop through spawnpoints
            for (var i = 0; i < spawnPoints.length; i++) {

                //Add spawnpoints to reservedBlocks[]
                reservedBlocks.push({
                    X: spawnPoints[i].X,
                    Y: spawnPoints[i].Y
                });

                var surroundings = returnSurroundings(spawnPoints[i].X, spawnPoints[i].Y, reservedBlocksInEachDirectionFromSpawnPoints);

                for (var j = 0; j < surroundings.Directions.length; j++) {

                    for (var k = 0; k < reservedBlocksInEachDirectionFromSpawnPoints; k++) {

                        if (surroundings.Directions[j][k] != null) {

                            reservedBlocks.push({
                                X: surroundings.Directions[j][k].MapPos.X,
                                Y: surroundings.Directions[j][k].MapPos.Y
                            });

                        }
                        
                    }

                }

            }

        }

        function findBlock(posX, posY) {

            for (var i = 0; i < map.length; i++) {

                if(posX === map[i].MapPos.X && posY === map[i].MapPos.Y) {

                    return map[i];
                    break;

                }

            }

        }

        function returnSurroundings(posX, posY, range) {

            var Surroundings = {

                Range: range,
                Center: findBlock(posX, posY),
                Directions: [
                    [],
                    [],
                    [],
                    []
                ]

            };

            for (var i = 0, d = 0, r = 1; i < 4 * range; i++) {

                if(i != 0 && i % range === 0) {
                    d++;
                }
                if (r === range + 1) {
                    r = 1;
                }
                switch(d) {
                    case 0: {
                        Surroundings.Directions[d].push(findBlock(Surroundings.Center.MapPos.X, Surroundings.Center.MapPos.Y - r));
                    } break;
                    case 1: {
                        Surroundings.Directions[d].push(findBlock(Surroundings.Center.MapPos.X + r, Surroundings.Center.MapPos.Y));
                    } break;
                    case 2: {
                        Surroundings.Directions[d].push(findBlock(Surroundings.Center.MapPos.X, Surroundings.Center.MapPos.Y + r));
                    } break;
                    case 3: {
                        Surroundings.Directions[d].push(findBlock(Surroundings.Center.MapPos.X - r, Surroundings.Center.MapPos.Y));
                    } break;
                }
                r++;

            };

            return Surroundings;

        }

        function generateCrates() {

            for (var i = 0; i < map.length; i++) {

                if (map[i].BlockType.blockType === blockType.type_empty) {

                    var isReserved = false;
                    for (var j = 0; j < reservedBlocks.length; j++) {

                        if (map[i].MapPos.X === reservedBlocks[j].X && map[i].MapPos.Y === reservedBlocks[j].Y) {

                            isReserved = true;
                            break;

                        }

                    }

                    if (!isReserved) {

                        if (Math.random() < cratesPercentage) {

                            map[i].BlockType.blockType = blockType.type_crate;

                        }

                    }

                }

            }

        }

        function drawMap() {

            for (var i = 0; i < map.length; i++) {
                if (map[i].BlockType.blockType === blockType.type_wall) {
                    ctx.fillStyle = "black";
                }
                else if (map[i].BlockType.blockType === blockType.type_empty) {
                    if (map[i].OnFire === true) {
                        ctx.fillStyle = "orange";
                    } else if (map[i].HasBomb) {
                        ctx.fillStyle = "red";
                    } else {
                        ctx.fillStyle = "green";
                    }
                }
                else if (map[i].BlockType.blockType === blockType.type_crate) {
                    ctx.fillStyle = "brown";
                }
                ctx.fillRect(map[i].MapPos.X * blockSize, map[i].MapPos.Y * blockSize, blockSize, blockSize);
            }

        }

        function drawPlayers() {

            for (var i = 0; i < Players.length; i++) {
                ctx.fillStyle = Players[i].playerColor;
                ctx.fillRect(Players[i].CanvasPos.X, Players[i].CanvasPos.Y, Players[i].Size.Width, Players[i].Size.Height);
                ctx.fillStyle = 'black';
            }

        }

        function newGame() {

            makeMap();
            addReservedBlocks();
            generateCrates();
            drawMap();
            drawPlayers();

        }

        function movePlayer(player) {

            posX = player.CanvasPos.X;
            posY = player.CanvasPos.Y;

            if (player.XKeys.right === true && player.XKeys.left === false) {
                player.CanvasPos.X = player.CanvasPos.X + player.playerSpeed;
            }
            else if (player.XKeys.right === false && player.XKeys.left === true) {
                player.CanvasPos.X = player.CanvasPos.X - player.playerSpeed;
            }

            if (player.YKeys.up === true && player.YKeys.down === false) {
                player.CanvasPos.Y = player.CanvasPos.Y - player.playerSpeed;
            }
            else if (player.YKeys.up === false && player.YKeys.down === true) {
                player.CanvasPos.Y = player.CanvasPos.Y + player.playerSpeed;
            }



            for (var i = 0; i < map.length; i++) {
                if (map[i].BlockType.blockType === blockType.type_wall || map[i].BlockType.blockType === blockType.type_crate) {
                    if (checkCollision(player, map[i])) {
                        player.CanvasPos.X = posX;
                        player.CanvasPos.Y = posY;
                    }
                } else {
                    player.MapPos.X = Math.floor(player.CanvasPos.X / blockSize);
                    player.MapPos.Y = Math.floor(player.CanvasPos.Y / blockSize);
                    continue;
                }
            }

        }

        function checkCollision(obj1, obj2) {

            if (obj1.CanvasPos.X < obj2.CanvasPos.X + obj2.Size.Width &&
                obj1.CanvasPos.X + obj1.Size.Width > obj2.CanvasPos.X &&
                obj1.CanvasPos.Y < obj2.CanvasPos.Y + obj2.Size.Height &&
                obj1.Size.Height + obj1.CanvasPos.Y > obj2.CanvasPos.Y) {

                return true;

            }
            else {
                return false;
            }

        }

        function isValidPlaceToLayBomb(x, y) {

            var isValid = true;
            var block = findBlock(x, y);
            
            if (block.HasBomb === true || block.OnFire === true) {
            
                isValid = false;

            }

            return isValid;
        }

        newGame();

        timer.tick = function () {

            for (var i = 0; i < Players.length; i++) {
                movePlayer(Players[i]);
            }

            ctx.clearRect(0, 0, c.width, c.height);
            drawMap();
            drawPlayers();
        };

        $(document).keydown(function (e) {

            switch (e.keyCode) {

/*ENTER*/           case 13: {
                        if (timer.stopped) {
                            timer.start();
                        } else {
                            timer.stop();
                        }
                    } break;

/*Player 1*/

/*W*/               case 87: {
                        Players[0].YKeys.up = true;
                        Players[0].currentDirection = Direction.UP;
                    } break;

/*D*/               case 68: {
                        Players[0].XKeys.right = true;
                        Players[0].currentDirection = Direction.RIGHT;
                    } break;

/*S*/               case 83: {
                        Players[0].YKeys.down = true;
                        Players[0].currentDirection = Direction.DOWN;
                    } break;

/*A*/               case 65: {
                        Players[0].XKeys.left = true;
                        Players[0].currentDirection = Direction.LEFT;
                    } break;
/*SPACE*/           case 32: {
                        if (!timer.stopped) {

                            if (Players[0].amountOfBombs > 0) {

                                var block = findBlock(Players[0].MapPos.X, Players[0].MapPos.Y);

                                if (isValidPlaceToLayBomb(block.MapPos.X, block.MapPos.Y)) {

                                    Players[0].amountOfBombs = Players[0].amountOfBombs - 1;
                                    Players[0].dropBomb(block.MapPos.X, block.MapPos.Y, Players[0].equippedBomb, Players[0]);

                                }

                            } 

                        }
                    } break;

/*Player 2*/

/*UP*/              case 38: {
                        Players[1].YKeys.up = true;
                        Players[1].currentDirection = Direction.UP;
                    } break;

/*RIGHT*/           case 39: {
                        Players[1].XKeys.right = true;
                        Players[1].currentDirection = Direction.RIGHT;
                    } break;

/*DOWN*/            case 40: {
                        Players[1].YKeys.down = true;
                        Players[1].currentDirection = Direction.DOWN;
                    } break;

/*LEFT*/            case 37: {
                        Players[1].XKeys.left = true;
                        Players[1].currentDirection = Direction.LEFT;
                    } break;
/*FORWARD SLASH*/   case 191: {
                        if (!timer.stopped) {

                            if (Players[1].amountOfBombs > 0) {

                                var block = findBlock(Players[1].MapPos.X, Players[1].MapPos.Y);

                                if (isValidPlaceToLayBomb(block.MapPos.X, block.MapPos.Y)) {

                                    Players[1].amountOfBombs = Players[1].amountOfBombs - 1;
                                    Players[1].dropBomb(block.MapPos.X, block.MapPos.Y, Players[1].equippedBomb, Players[1]);

                                }

                            }
                                
                        }
                    } break;

            }

        });

        $(document).keyup(function (e) {

            switch (e.keyCode) {

/*Player 1*/

/*W*/           case 87: {
                    Players[0].YKeys.up = false;
                } break;

/*D*/           case 68: {
                    Players[0].XKeys.right = false;
                } break;

/*S*/           case 83: {
                    Players[0].YKeys.down = false;
                } break;

/*A*/           case 65: {
                    Players[0].XKeys.left = false;
                } break;

/*Player 2*/

/*UP*/          case 38: {
                    Players[1].YKeys.up = false;
                } break;

/*RIGHT*/       case 39: {
                    Players[1].XKeys.right = false;
                } break;

/*DOWN*/        case 40: {
                    Players[1].YKeys.down = false;
                } break;

/*LEFT*/        case 37: {
                    Players[1].XKeys.left = false;
                } break;

            }

        });

        function Player(x, y, id, color) {

            this.MapPos = {
                X: x,
                Y: y
            },
            this.CanvasPos = {
                X: Math.floor(x * blockSize),
                Y: Math.floor(y * blockSize)
            },
            this.Size = {
                Width: playerSize,
                Height: playerSize
            },
            this.XKeys = {
                right: false,
                left: false
            },
            this.YKeys = {
                up: false,
                down: false
            },
            this.playerID = id,
            this.playerColor = color,
            this.playerSpeed = initialPlayerSpeed,
            this.health = initialHealth;
            this.currentDirection = Direction.RIGHT,
            this.amountOfBombs = initialAmountOfBombs,
            this.explosionRange = initialBombRange,
            this.equippedBomb = bombType.type_basic;
            this.dropBomb = function (x, y, bombType, player) {

                var block = findBlock(x, y);
                block.HasBomb = true;
                block.Bomb = new Bomb(block.MapPos.X, block.MapPos.Y, bombType, player);

                setTimeout(function () {
                    if (block.Bomb != null) {
                        block.Bomb.Explode(x, y, bombType, player);
                    }
                }, explosionTime);
                
            }

        }

        function Bomb(mapPosX, mapPosY, bombType, player) {

            this.Player = player,
            this.Type = bombType,
            this.MapPos = {
                X: mapPosX,
                Y: mapPosY
            },
            this.CanvasPos = {
                X: Math.floor(mapPosX * blockSize),
                Y: Math.floor(mapPosY * blockSize)
            },
            this.Size = {
                Width: blockSize,
                Height: blockSize
            },
            this.Damage = 1,
            //this.Radius = initialBombRadius,
            this.Explode = function (x, y, bombType, player) {

                var block = findBlock(x, y);
                block.HasBomb = false;
                block.Bomb = null;
                player.amountOfBombs = player.amountOfBombs + 1;
                var explosionRadius = returnSurroundings(x, y, player.explosionRange);
                var blocksThatCatchFire = [];
                blocksThatCatchFire.push(explosionRadius.Center);
                
                for (var i = 0; i < explosionRadius.Directions.length; i++) {

                    for (var j = 0; j < explosionRadius.Directions[i].length; j++) {

                        if (explosionRadius.Directions[i][j] != null) {

                            if (explosionRadius.Directions[i][j].BlockType.blockType === blockType.type_empty) {
                            
                                blocksThatCatchFire.push(explosionRadius.Directions[i][j]);

                            } else if (explosionRadius.Directions[i][j].BlockType.blockType === blockType.type_wall) {
                            
                                break;

                            } else if (explosionRadius.Directions[i][j].BlockType.blockType === blockType.type_crate) {
                            
                                blocksThatCatchFire.push(explosionRadius.Directions[i][j]);
                                break;

                            }

                        }

                    }

                }
                
                for (var i = 0; i < blocksThatCatchFire.length; i++) {
                    
                    switch (blocksThatCatchFire[i].BlockType.blockType) {
                        
                        case blockType.type_empty: {
                            if (blocksThatCatchFire[i].HasBomb) {
                                blocksThatCatchFire[i].Bomb.Explode(blocksThatCatchFire[i].MapPos.X, blocksThatCatchFire[i].MapPos.Y, blocksThatCatchFire[i].Bomb.Type, player);
                            }
                            blocksThatCatchFire[i].CatchOnFire(blocksThatCatchFire[i].MapPos.X, blocksThatCatchFire[i].MapPos.Y, player);
                        } break;
                        case blockType.type_crate: {
                            blocksThatCatchFire[i].BlockType.blockType = blockType.type_empty
                            blocksThatCatchFire[i].CatchOnFire(blocksThatCatchFire[i].MapPos.X, blocksThatCatchFire[i].MapPos.Y, player);
                        } break;

                    }

                }

                

            }

        }

        function Timer() {

            this.interval = 0;
            this.stopped = true;
            this.timeout;
            this.timeStarted;
            this.isLoop = false;
            this.tick = function () { }
            this.ticki = function () {

                if (!self.stopped) {

                    self.tick();

                    if (self.isLoop) {
                        self.continue();
                    } else {
                        self.stopped = true;
                    }

                }

            }
            this.start = function () {
                self.timeStarted = Date.now();
                self.stopped = false;
                self.continue();
            }
            this.continue = function () {
                self.timeout = setTimeout(self.ticki, self.interval);
            }
            this.stop = function () {
                self.stopped = true;
            }
            this.add = function (now, time) {
                var newTime = self.interval - (now - self.timeStarted) + time;
                clearTimeout(self.timeout);
                self.timeout = setTimeout(self.ticki, newTime);
            }
            var self = this;

        }

    </script>
</body>
</html>
